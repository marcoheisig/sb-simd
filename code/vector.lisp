(declaim (sb-ext:muffle-conditions style-warning))
(in-package #:sb-vm)
(eval-when (:compile-toplevel :load-toplevel :execute)
  (sb-simd::macro-when
      (and (find-symbol "VFMADD231PD" sb-assem::*backend-instruction-set-package*)
           (sb-alien:extern-alien "avx2_supported" sb-alien:int))
    (defknown (%f64.4-vdot) ((simple-array double-float (*))
                             (simple-array double-float (*))
                             (integer 0 #.most-positive-fixnum))
        double-float
        (movable flushable always-translatable)
      :overwrite-fndb-silently t)
    (define-vop (%f64.4-vdot)
      (:translate %f64.4-vdot)
      (:policy :fast-safe)
      (:args (u  :scs (descriptor-reg))
             (v  :scs (descriptor-reg))
             (n0-tn :scs (signed-reg)))
      (:arg-types simple-array-double-float simple-array-double-float
                  tagged-num)
      (:temporary (:sc signed-reg) i)
      (:temporary (:sc signed-reg) n0)
      (:temporary (:sc double-avx2-reg) ymm0)
      (:temporary (:sc double-avx2-reg) ymm1)
      (:temporary (:sc double-avx2-reg) ymm2)
      (:temporary (:sc double-avx2-reg) ymm3)
      (:temporary (:sc double-avx2-reg) ymm4)
      (:temporary (:sc double-avx2-reg) ymm5)
      (:temporary (:sc double-avx2-reg) ymm6)
      (:temporary (:sc double-avx2-reg) ymm7)
      (:temporary (:sc double-sse-reg)  xmm0)
      (:temporary (:sc double-sse-reg)  xmm1)
      (:results (result :scs (double-reg)))
      (:result-types double-float)
      (:generator 22
                  (move n0 n0-tn)
                  (inst vxorpd ymm4 ymm4 ymm4)
                  (inst vxorpd ymm5 ymm5 ymm5)
                  (inst vxorpd ymm6 ymm6 ymm6)
                  (inst vxorpd ymm7 ymm7 ymm7)
                  (inst xor i i)
                  LOOP
                  (inst vmovupd ymm0 (float-ref-ea u i 0 8 :scale 2))
                  (inst vmovupd ymm1 (float-ref-ea u i 4 8 :scale 2))
                  (inst vmovupd ymm2 (float-ref-ea u i 8 8 :scale 2))
                  (inst vmovupd ymm3 (float-ref-ea u i 12 8 :scale 2))
                  (inst vfmadd231pd ymm4 ymm0 (float-ref-ea v i 0 8 :scale 2))
                  (inst vfmadd231pd ymm5 ymm1 (float-ref-ea v i 4 8 :scale 2))
                  (inst vfmadd231pd ymm6 ymm2 (float-ref-ea v i 8 8 :scale 2))
                  (inst vfmadd231pd ymm7 ymm3 (float-ref-ea v i 12 8 :scale 2))
                  (inst add i 16)
                  (inst cmp i n0)
                  (inst jmp :b LOOP)
                  DONE
                  (inst vaddpd ymm4 ymm4 ymm5)
                  (inst vaddpd ymm6 ymm6 ymm7)
                  (inst vaddpd ymm4 ymm4 ymm6)
                  (inst vmovapd xmm0 ymm4)
                  (inst vextractf128 xmm1 ymm4 1)
                  (inst vaddpd xmm0 xmm0 xmm1)
                  (inst vpermilpd xmm1 xmm0 1)
                  (inst vaddsd result xmm0 xmm1)
                  (inst vzeroupper))))
  
  (sb-simd::macro-when
      (and (find-symbol "VFMADD231PS" sb-assem::*backend-instruction-set-package*)
           (sb-alien:extern-alien "avx2_supported" sb-alien:int))
    (defknown (%f32.8-vdot) ((simple-array single-float (*))
                             (simple-array single-float (*))
                             (integer 0 #.most-positive-fixnum))
        single-float
        (movable flushable always-translatable)
      :overwrite-fndb-silently t)
    (define-vop (%f32.8-vdot)
      (:translate %f32.8-vdot)
      (:policy :fast-safe)
      (:args (u  :scs (descriptor-reg))
             (v  :scs (descriptor-reg))
             (n0-tn :scs (signed-reg)))
      (:arg-types simple-array-single-float simple-array-single-float
                  tagged-num)
      (:temporary (:sc signed-reg) i)
      (:temporary (:sc signed-reg) n0)
      (:temporary (:sc single-avx2-reg) ymm0)
      (:temporary (:sc single-avx2-reg) ymm1)
      (:temporary (:sc single-avx2-reg) ymm2)
      (:temporary (:sc single-avx2-reg) ymm3)
      (:temporary (:sc single-avx2-reg) ymm4)
      (:temporary (:sc single-avx2-reg) ymm5)
      (:temporary (:sc single-avx2-reg) ymm6)
      (:temporary (:sc single-avx2-reg) ymm7)
      (:temporary (:sc single-sse-reg)  xmm0)
      (:temporary (:sc single-sse-reg)  xmm1)
      (:results (result :scs (single-reg)))
      (:result-types single-float)
      (:generator 22
                  (move n0 n0-tn)
                  (inst vxorps ymm4 ymm4 ymm4)
                  (inst vxorps ymm5 ymm5 ymm5)
                  (inst vxorps ymm6 ymm6 ymm6)
                  (inst vxorps ymm7 ymm7 ymm7)
                  (inst xor i i)
                  LOOP
                  (inst vmovups ymm0 (float-ref-ea u i 0 0))
                  (inst vmovups ymm1 (float-ref-ea u i 8 0))
                  (inst vmovups ymm2 (float-ref-ea u i 16 0))
                  (inst vmovups ymm3 (float-ref-ea u i 24 0))
                  (inst vfmadd231ps ymm4 ymm0 (float-ref-ea v i 0 0))
                  (inst vfmadd231ps ymm5 ymm1 (float-ref-ea v i 8 0))
                  (inst vfmadd231ps ymm6 ymm2 (float-ref-ea v i 16 0))
                  (inst vfmadd231ps ymm7 ymm3 (float-ref-ea v i 24 0))
                  (inst add i 32)
                  (inst cmp i n0)
                  (inst jmp :b LOOP)
                  DONE
                  (inst vaddps ymm4 ymm4 ymm5)
                  (inst vaddps ymm6 ymm6 ymm7)
                  (inst vaddps ymm4 ymm4 ymm6)
                  (inst vmovaps xmm0 ymm4)
                  (inst vextractf128 xmm1 ymm4 1)
                  (inst vaddps xmm0 xmm0 xmm1)
                  (inst vpermilpd xmm1 xmm0 1)
                  (inst vaddps xmm0 xmm0 xmm1)
                  (inst vmovshdup xmm1 xmm0)
                  (inst vaddss result xmm0 xmm1)
                  (inst vzeroupper))))

  (sb-simd::macro-when
   (sb-alien:extern-alien "avx_supported" sb-alien:int)
   (defknown (%f64.4-vsum) ((simple-array double-float (*))
                            (integer 0 #.most-positive-fixnum))
       double-float
       (movable flushable always-translatable)
     :overwrite-fndb-silently t)
   (define-vop (%f64.4-vsum)
     (:translate %f64.4-vsum)
     (:policy :fast-safe)
     (:args (u  :scs (descriptor-reg))
            (n0-tn :scs (signed-reg)))
     (:arg-types simple-array-double-float tagged-num)
     (:temporary (:sc unsigned-reg) i)
     (:temporary (:sc unsigned-reg) n0)
     (:temporary (:sc double-avx2-reg) ymm0)
     (:temporary (:sc double-avx2-reg) ymm1)
     (:temporary (:sc double-avx2-reg) ymm2)
     (:temporary (:sc double-avx2-reg) ymm3)
     (:temporary (:sc double-sse-reg)  xmm0)
     (:temporary (:sc double-sse-reg)  xmm1)
     (:results (result :scs (double-reg)))
     (:result-types double-float)
     (:generator 16
                 (move n0 n0-tn)
                 (inst vxorpd ymm0 ymm0 ymm0)
                 (inst vxorpd ymm1 ymm1 ymm1)
                 (inst vxorpd ymm2 ymm2 ymm2)
                 (inst vxorpd ymm3 ymm3 ymm3)
                 (inst xor i i)
                 LOOP
                 (inst vaddpd ymm0 ymm0 (float-ref-ea u i 0 0 :scale 4))
                 (inst vaddpd ymm1 ymm1 (float-ref-ea u i 4 0 :scale 4))
                 (inst vaddpd ymm2 ymm2 (float-ref-ea u i 8 0 :scale 4))
                 (inst vaddpd ymm3 ymm3 (float-ref-ea u i 12 0 :scale 4))
                 (inst add i 16)
                 (inst cmp i n0)
                 (inst jmp :b LOOP)
                 DONE
                 (inst vaddpd ymm0 ymm0 ymm1)
                 (inst vaddpd ymm2 ymm2 ymm3)
                 (inst vaddpd ymm0 ymm0 ymm2)
                 (inst vmovapd xmm0 ymm0)
                 (inst vextractf128 xmm1 ymm0 1)
                 (inst vaddpd xmm0 xmm0 xmm1)
                 (inst vunpckhpd xmm1 xmm0 xmm0)
                 (inst vaddsd result xmm0 xmm1)
                 (inst vzeroupper)))

    (defknown (%f32.8-vsum) ((simple-array single-float (*))
                             (integer 0 #.most-positive-fixnum))
        single-float
        (movable flushable always-translatable)
      :overwrite-fndb-silently t)
    (define-vop (%f32.8-vsum)
      (:translate %f32.8-vsum)
      (:policy :fast-safe)
      (:args (u  :scs (descriptor-reg))
             (n0-tn :scs (signed-reg)))
      (:arg-types simple-array-single-float tagged-num)
      (:temporary (:sc signed-reg) i)
      (:temporary (:sc signed-reg) n0)
      (:temporary (:sc single-avx2-reg) ymm0)
      (:temporary (:sc single-avx2-reg) ymm1)
      (:temporary (:sc single-avx2-reg) ymm2)
      (:temporary (:sc single-avx2-reg) ymm3)
      (:temporary (:sc single-sse-reg)  xmm0)
      (:temporary (:sc single-sse-reg)  xmm1)
      (:results (result :scs (single-reg)))
      (:result-types single-float)
      (:generator 22
                  (move n0 n0-tn)
                  (inst vxorps ymm0 ymm0 ymm0)
                  (inst vxorps ymm1 ymm1 ymm1)
                  (inst vxorps ymm2 ymm2 ymm2)
                  (inst vxorps ymm3 ymm3 ymm3)
                  (inst xor i i)
                  LOOP
                  (inst vaddps ymm0 ymm0 (float-ref-ea u i 0 0))
                  (inst vaddps ymm1 ymm1 (float-ref-ea u i 8 0))
                  (inst vaddps ymm2 ymm2 (float-ref-ea u i 16 0))
                  (inst vaddps ymm3 ymm3 (float-ref-ea u i 24 0))
                  (inst add i 32)
                  (inst cmp i n0)
                  (inst jmp :b LOOP)
                  DONE
                  (inst vaddps ymm0 ymm0 ymm1)
                  (inst vaddps ymm2 ymm2 ymm3)
                  (inst vaddps ymm0 ymm0 ymm2)
                  (inst vmovaps xmm0 ymm0)
                  (inst vextractf128 xmm1 ymm0 1)
                  (inst vaddps xmm0 xmm0 xmm1)
                  (inst vmovshdup xmm1 xmm0)
		  (inst vaddps xmm0 xmm0 xmm1)
		  (inst vmovhlps xmm0 xmm0 xmm1)
		  (inst vaddss result xmm1 xmm0)
                  (inst vzeroupper)))

    (defknown (%f64.4-hsum) ((simd-pack-256 double-float))
          double-float
          (movable flushable always-translatable)
        :overwrite-fndb-silently t)
      (define-vop (%f64.4-hsum)
        (:translate %f64.4-hsum)
        (:policy :fast-safe)
        (:args (x :scs (double-avx2-reg)))
        (:arg-types simd-pack-256-double)
        (:temporary (:sc double-sse-reg) xmm0)
        (:temporary (:sc double-sse-reg) xmm1)
        ;(:results (result :scs (double-sse-reg) :from (:argument 0)))
        (:results (result :scs (double-reg)))
        (:result-types double-float)
        (:generator 4 ;; what should be the cost?
                    (inst vmovapd xmm0 x)
                    (inst vextractf128 xmm1 x 1)
                    (inst vaddpd xmm0 xmm0 xmm1)
                    (inst vunpckhpd xmm1 xmm0 xmm0)
                    (inst vaddsd result xmm0 xmm1)
                    (inst vzeroupper)))

      (defknown (%f32.8-hsum) ((simd-pack-256 single-float))
          single-float
          (movable flushable always-translatable)
        :overwrite-fndb-silently t)
      (define-vop (%f32.8-hsum)
        (:translate %f32.8-hsum)
        (:policy :fast-safe)
        (:args (x :scs (single-avx2-reg)))
        (:arg-types simd-pack-256-single)
        (:temporary (:sc single-sse-reg) xmm0)
        (:temporary (:sc single-sse-reg) xmm1)
        (:results (result :scs (single-reg)))
        (:result-types single-float)
        (:generator 4 ;; what should be the cost?
                    (inst vmovaps xmm0 x)
                    (inst vextractf128 xmm1 x 1)
                    (inst vaddps xmm0 xmm0 xmm1)
                    (inst vmovshdup xmm1 xmm0)
		    (inst vaddps xmm0 xmm0 xmm1)
		    (inst vmovhlps xmm0 xmm0 xmm1)
		    (inst vaddss result xmm1 xmm0)
                    (inst vzeroupper)))

    (defknown (%f64.2-hsum) ((simd-pack double-float))
        double-float
        (movable flushable always-translatable)
      :overwrite-fndb-silently t)
    (define-vop (%f64.2-hsum)
      (:translate %f64.2-hsum)
      (:policy :fast-safe)
      (:args (x :scs (double-sse-reg)))
      (:arg-types simd-pack-double)
      (:temporary (:sc double-sse-reg) xmm0)
      (:temporary (:sc double-sse-reg) xmm1)
      (:results (result :scs (double-reg)))
      (:result-types double-float)
      (:generator 4 ;; what should be the cost?
                  (inst vmovapd xmm0 x)
                  (inst vextractf128 xmm1 x 1)
                  (inst vaddpd xmm0 xmm0 xmm1)
                  (inst vunpckhpd xmm1 xmm0 xmm0)
                  (inst vaddsd result xmm0 xmm1)
                  (inst vzeroupper)))

    (defknown (%f32.4-hsum) ((simd-pack single-float))
        single-float
        (movable flushable always-translatable)
      :overwrite-fndb-silently t)
    (define-vop (%f32.4-hsum)
      (:translate %f32.4-hsum)
      (:policy :fast-safe)
      (:args (xmm0 :scs (single-sse-reg)))
      (:arg-types simd-pack-single)
      (:temporary (:sc single-sse-reg) xmm1)
      (:results (result :scs (single-reg)))
      (:result-types single-float)
      (:generator 4 ;; what should be the cost?
                  (inst movshdup xmm1 xmm0)
		  (inst addps xmm0 xmm1)
		  (inst movhlps xmm1 xmm0)
		  (inst addps result xmm1)))

    (defknown (%f64.4-rec13) ((simd-pack-256 double-float)
                           (simd-pack-256 double-float))
        (simd-pack-256 double-float)
        (movable flushable always-translatable)
      :overwrite-fndb-silently t)
    (define-vop (%f64.4-rec13)
      (:translate %f64.4-rec13)
      (:policy :fast-safe)
      (:args (x :scs (double-avx2-reg))
             (two :scs (double-avx2-reg)))    
      (:arg-types simd-pack-256-double simd-pack-256-double)
      (:temporary (:sc double-avx2-reg) ymm0)
      (:temporary (:sc double-avx2-reg) ymm1)
      (:temporary (:sc double-avx2-reg) ymm2)
      (:results (dest :scs (double-avx2-reg)))
      (:result-types simd-pack-256-double)
      (:generator 8 ;; what should be the cost?
                  (inst vmovapd ymm0 x)
        	  (inst vcvtpd2ps ymm0 ymm0)
        	  (inst vrcpps ymm0 ymm0)
        	  (inst vcvtps2pd ymm0 ymm0)
        	  (inst vmulpd ymm2 two ymm0)
        	  (inst vmulpd ymm0 ymm0 ymm0)
        	  (inst vmulpd ymm1 x ymm0)
        	  (inst vsubpd ymm0 ymm2 ymm1)
        	  (inst vmulpd ymm2 two ymm0)
        	  (inst vmulpd ymm0 ymm0 ymm0)
        	  (inst vmulpd ymm1 x ymm0)
        	  (inst vsubpd dest ymm2 ymm1)))

    (defknown (%f64.4-rec9) ((simd-pack-256 double-float)
                             (simd-pack-256 double-float))
        (simd-pack-256 double-float)
        (movable flushable always-translatable)
      :overwrite-fndb-silently t)
    (define-vop (%f64.4-rec9)
      (:translate %f64.4-rec9)
      (:policy :fast-safe)
      (:args (x :scs (double-avx2-reg))
             (three :scs (double-avx2-reg)))    
      (:arg-types simd-pack-256-double simd-pack-256-double)
      (:temporary (:sc single-avx2-reg) xmm1)
      (:temporary (:sc double-avx2-reg) ymm0)
      (:temporary (:sc double-avx2-reg) ymm1)
      (:temporary (:sc double-avx2-reg) ymm2)
      (:results (dest :scs (double-avx2-reg)))
      (:result-types simd-pack-256-double)
      (:generator 8 ;; what should be the cost?
                  (inst vmovapd ymm0 x)
        	  (inst vcvtpd2ps xmm1 x)
        	  (inst vrcpps xmm1 xmm1)
        	  (inst vcvtps2pd ymm1 xmm1)
        	  (inst vmulpd ymm0 x ymm1)
        	  (inst vmulpd ymm2 ymm1 ymm0)
        	  (inst vsubpd ymm0 ymm0 three)
                  (inst vmulpd ymm1 ymm1 three)
        	  (inst vmulpd ymm0 ymm2 ymm0)
        	  (inst vaddpd dest ymm0 ymm1)))

    (defknown (%f64.4-rsqrt13) ((simd-pack-256 double-float)
                                (simd-pack-256 double-float)
                                (simd-pack-256 double-float))
        (simd-pack-256 double-float)
        (movable flushable always-translatable)
    :overwrite-fndb-silently t)
  (define-vop (%f64.4-rsqrt13)
    (:translate %f64.4-rsqrt13)
    (:policy :fast-safe)
    (:args (x :scs (double-avx2-reg))
	   (half :scs (double-avx2-reg))
	   (threehalfs :scs (double-avx2-reg)))    
    (:arg-types simd-pack-256-double simd-pack-256-double simd-pack-256-double)
    (:temporary (:sc double-avx2-reg) ymm0)
    (:temporary (:sc double-avx2-reg) ymm1)
    (:temporary (:sc double-avx2-reg) ymm2)
    (:temporary (:sc double-avx2-reg) ymm3)
    (:results (dest :scs (double-avx2-reg)))
    (:result-types simd-pack-256-double)
    (:generator 8 ;; what should be the cost?
		(inst vcvtpd2ps ymm0 x)
		(inst vrsqrtps ymm0 ymm0)
		(inst vcvtps2pd ymm0 ymm0)
		(inst vmulpd ymm2 threehalfs ymm0)
		(inst vmulpd ymm3 ymm0 ymm0)
		(inst vmulpd ymm1 x ymm0)
		(inst vmulpd ymm0 ymm1 ymm3)
		(inst vmulpd ymm0 half ymm0)
		(inst vsubpd ymm0 ymm2 ymm0)
		(inst vmulpd ymm2 threehalfs ymm0)
		(inst vmulpd ymm3 ymm0 ymm0)
		(inst vmulpd ymm1 x ymm0)
		(inst vmulpd ymm0 ymm1 ymm3)
		(inst vmulpd ymm0 half ymm0)
		(inst vsubpd dest ymm2 ymm0)))

    (defknown (%f64.4-rsqrt9) ((simd-pack-256 double-float) ;;incorrect result
                               (simd-pack-256 double-float)
                               (simd-pack-256 double-float)
                               (simd-pack-256 double-float))
        (simd-pack-256 double-float)
        (movable flushable always-translatable)
      :overwrite-fndb-silently t)
    (define-vop (%f64.4-rsqrt9)
      (:translate %f64.4-rsqrt9)
      (:policy :fast-safe)
      (:args (x :scs (double-avx2-reg))
             (%0375 :scs (double-avx2-reg))
             (%1250 :scs (double-avx2-reg))
             (%1875 :scs (double-avx2-reg)))    
      (:arg-types simd-pack-256-double simd-pack-256-double
                  simd-pack-256-double simd-pack-256-double)
      (:temporary (:sc double-avx2-reg) xmm1)
      (:temporary (:sc double-avx2-reg) ymm0)
      (:temporary (:sc double-avx2-reg) ymm1)
      (:temporary (:sc double-avx2-reg) ymm2)
      (:results (dest :scs (double-avx2-reg)))
      (:result-types simd-pack-256-double)
      (:generator 8 ;; what should be the cost?
                  (inst vmovapd ymm0 x)
        	  (inst vcvtpd2ps xmm1 x)
        	  (inst vrsqrtps xmm1 xmm1)
        	  (inst vcvtps2pd ymm1 xmm1)
                  (inst vmulpd ymm0 ymm1 ymm0)
                  (inst vmulpd ymm0 ymm0 ymm1)
        	  (inst vmulpd ymm2 ymm0 %0375)
        	  (inst vmulpd ymm2 ymm0 ymm2)
                  (inst vmulpd ymm0 ymm0 %1250)
                  (inst vaddpd ymm0 ymm0 %1875)
        	  (inst vsubpd ymm0 ymm2 ymm0)
        	  (inst vmulpd dest ymm0 ymm1)))

    (defknown (%f64.2-zeros) ()
        (simd-pack double-float)
        (movable flushable always-translatable)
      :overwrite-fndb-silently t)
    (define-vop (%f64.2-zeros)
      (:translate %f64.2-zeros)
      (:policy :fast-safe)
      (:results (result :scs (double-sse-reg)))
      (:result-types simd-pack-double)
      (:generator 4
                  (inst xorpd result result)))
    
    (defknown (%f32.4-zeros) ()
        (simd-pack single-float)
        (movable flushable always-translatable)
      :overwrite-fndb-silently t)
    (define-vop (%f32.4-zeros)
      (:translate %f32.4-zeros)
      (:policy :fast-safe)
      (:results (result :scs (single-sse-reg)))
      (:result-types simd-pack-single)
      (:generator 1
                  (inst xorps result result)))

    (defknown (%f64.4-zeros) ()
        (simd-pack-256 double-float)
        (movable flushable always-translatable)
      :overwrite-fndb-silently t)
    (define-vop (%f64.4-zeros)
      (:translate %f64.4-zeros)
      (:policy :fast-safe)
      (:results (result :scs (double-avx2-reg)))
      (:result-types simd-pack-256-double)
      (:generator 4
                  (inst vxorpd result result result)))

    (defknown (%f32.8-zeros) ()
        (simd-pack-256 single-float)
        (movable flushable always-translatable)
      :overwrite-fndb-silently t)
    (define-vop (%f32.8-zeros)
      (:translate %f32.8-zeros)
      (:policy :fast-safe)
      (:results (result :scs (single-avx2-reg)))
      (:result-types simd-pack-256-single)
      (:generator 4
                  (inst vxorps result result result)))

    (defknown (%f64.4-extractf128)
        ((simd-pack-256 double-float) (integer 0 1))
        (simd-pack double-float)
        (flushable)
      :overwrite-fndb-silently t)
    (define-vop (%f64.4-extractf128)
      (:translate %f64.4-extractf128)
      (:args (x :scs (double-avx2-reg)))
      (:arg-types simd-pack-256-double (:constant t))
      (:info index)
      (:results (dst :scs (double-sse-reg)))
      (:result-types simd-pack-double)
      (:policy :fast-safe)
      (:generator 3
        	  (inst vextractf128 dst x index)
        	  (inst vzeroupper)))

    (defknown (%f32.8-extractf128)
        ((simd-pack-256 single-float) (integer 0 1))
        (simd-pack single-float)
        (flushable)
      :overwrite-fndb-silently t)
    (define-vop (%f32.8-extractf128)
      (:translate %f32.8-extractf128)
      (:args (x :scs (single-avx2-reg)))
      (:arg-types simd-pack-256-single (:constant t))
      (:info index)
      (:results (dst :scs (single-sse-reg)))
      (:result-types simd-pack-single)
      (:policy :fast-safe)
      (:generator 3
        	  (inst vextractf128 dst x index)
        	  (inst vzeroupper)))
    )
  
  (sb-simd::macro-when
      (sb-alien:extern-alien "avx2_supported" sb-alien:int)
    (defknown (%u64.4-extracti128)
        (simd-pack-256 (integer 0 1))
        simd-pack
        (flushable)
      :overwrite-fndb-silently t)
    (define-vop (%u64.4-extracti128)
      (:translate %u64.4-extracti128)
      (:args (x :scs (int-avx2-reg)))
      (:arg-types simd-pack-256-int (:constant t))
      (:info index)
      (:results (dst :scs (int-sse-reg)))
      (:result-types simd-pack-int)
      (:policy :fast-safe)
      (:generator 3
        	  (inst vextracti128 dst x index)
        	  (inst vzeroupper))))
  )

(in-package #:sb-simd)
(eval-when (:compile-toplevel :load-toplevel :execute)
  (sb-simd::macro-when
      (sb-alien:extern-alien "avx_supported" sb-alien:int)
    (declaim (ftype (function (f64.2) double-float) f64.2-hsum))
    (define-inline f64.2-hsum (%x)
      (declare (optimize (speed 3)))
      (sb-vm::%f64.2-hsum %x))
    (export 'f64.2-hsum)

    (declaim (ftype (function (f32.4) single-float) f32.4-hsum))
    (define-inline f32.4-hsum (%x)
      (declare (optimize (speed 3)))
      (sb-vm::%f32.4-hsum %x))
    (export 'f32.4-hsum)

    (declaim (ftype (function (f64.4) double-float) f64.4-hsum))
    (define-inline f64.4-hsum (%x)
      (declare (optimize speed))
      (sb-vm::%f64.4-hsum %x))
    (export 'f64.4-hsum)

    (declaim (ftype (function (f32.8) single-float) f32.8-hsum))
    (define-inline f32.8-hsum (%x)
      (declare (optimize speed))
      (sb-vm::%f32.8-hsum %x))
    (export 'f32.8-hsum)

    (declaim (ftype (function (f64.4) f64.4) f64.4-rec13))
    (define-inline f64.4-rec13 (%x)
      (declare (optimize speed))
      (sb-vm::%f64.4-rec13 %x (make-f64.4 2 2 2 2)))
    (export 'f64.4-rec13)

    (declaim (ftype (function (f64.4) f64.4) f64.4-rec9))
    (define-inline f64.4-rec9 (%x)
      (declare (optimize speed))
      (sb-vm::%f64.4-rec9 %x (make-f64.4 3 3 3 3)))
    (export 'f64.4-rec9)

    (declaim (ftype (function (f64.4) f64.4) f64.4-rsqrt13))
    (define-inline f64.4-rsqrt13 (%x)
      (declare (optimize speed))
      (sb-vm::%f64.4-rsqrt13 %x
                             (make-f64.4 0.5 0.5 0.5 0.5)
                             (make-f64.4 1.5 1.5 1.5 1.5)))
    (export 'f64.4-rsqrt13)

    (declaim (ftype (function (f64.4) f64.4) f64.4-rsqrt9))
    (define-inline f64.4-rsqrt9 (%x)
      (declare (optimize speed))
      (sb-vm::%f64.4-rsqrt9 %x
                             (make-f64.4 0.375 0.375 0.375 0.375)
                             (make-f64.4 1.250 1.250 1.250 1.250)
                             (make-f64.4 -1.875 -1.875 -1.875 -1.875)))
    (export 'f64.4-rsqrt9)

    (declaim (ftype (function () f64.4) f64.4-zeros))
    (define-inline f64.4-zeros ()
      (declare (optimize speed))
      (sb-vm::%f64.4-zeros))
    (export 'f64.4-zeros)

    (declaim (ftype (function () f32.8) f32.8-zeros))
    (define-inline f32.8-zeros ()
      (declare (optimize speed))
      (sb-vm::%f32.8-zeros))
    (export 'f32.8-zeros)

    (declaim (ftype (function (f64.4 (integer 0 1)) f64.2) f64.4-extractf128))
    (define-inline f64.4-extractf128 (%x index)
      (declare (optimize speed))
      (case index
        (0 (sb-vm::%f64.4-extractf128 %x index))
        (1 (sb-vm::%f64.4-extractf128 %x index))))
    (export 'f64.4-extractf128)

    (declaim (ftype (function (f32.8 (integer 0 1)) f32.4) f32.8-extractf128))
    (define-inline f32.8-extractf128 (%x index)
      (declare (optimize speed))
      (case index
        (0 (sb-vm::%f32.8-extractf128 %x index))
        (1 (sb-vm::%f32.8-extractf128 %x index))))
    (export 'f32.8-extractf128)
    )
  
  (sb-simd::macro-when
      (sb-alien:extern-alien "avx2_supported" sb-alien:int)
    (declaim (ftype (function (u64.4 (integer 0 1)) u64.2) u64.4-extracti128))
    (define-inline u64.4-extracti128 (%x index)
      (declare (optimize speed))
      (case index
        (0 (sb-vm::%u64.4-extracti128 %x index))
        (1 (sb-vm::%u64.4-extracti128 %x index))))
    (export 'u64.4-extracti128)

    (declaim (ftype (function (u32.8 (integer 0 1)) u32.4) u32.8-extracti128))
    (define-inline u32.8-extracti128 (%x index)
      (declare (optimize speed))
      (case index
        (0 (sb-vm::%u64.4-extracti128 %x index))
        (1 (sb-vm::%u64.4-extracti128 %x index))))
    (export 'u32.8-extracti128))

  (declaim (ftype (function () f64.2) f64.2-zeros))
  (define-inline f64.2-zeros ()
    (declare (optimize speed))
    (sb-vm::%f64.2-zeros))
  (export 'f64.2-zeros)
  
  (declaim (ftype (function () f32.4) f32.4-zeros))
  (define-inline f32.4-zeros ()
    (declare (optimize speed))
    (sb-vm::%f32.4-zeros))
  (export 'f32.4-zeros)
  )

  (sb-simd::macro-when
      (and (not (find-symbol "VFMADD231PD" sb-assem::*backend-instruction-set-package*))
           (sb-alien:extern-alien "avx2_supported" sb-alien:int))
    (declaim (ftype (function ((simple-array double-float (*))
                               (simple-array double-float (*)))
                              double-float) f64.4-vdot))
    (define-inline f64.4-vdot (u v)
      (declare (optimize speed))
      (let* ((n  (min (array-total-size u) (array-total-size v)))
             (n0 (- n (mod n 4))))
        (if (< n 4)
            (loop for i of-type fixnum below n
                  summing (* (aref u i) (aref v i))
                    into sum of-type double-float
                  finally (return sum))
            (+ (loop with %sum of-type f64.4 = (make-f64.4 0 0 0 0)
                     for i of-type fixnum below n0 by 4
                     do (f64.4-incf %sum (f64.4* (f64.4-ref u i) (f64.4-ref v i)))
                     finally (return (f64.4-hsum %sum)))
               (loop for i of-type fixnum from n0 below n
                     summing (* (aref u i) (aref v i))
                       into sum of-type double-float
                     finally (return sum))))))
    (export 'f64.4-vdot)

    (declaim (ftype (function ((simple-array single-float (*))
                               (simple-array single-float (*)))
                              single-float) f32.8-vdot))
    (define-inline f32.8-vdot (u v)
      (declare (optimize speed))
      (let* ((n  (min (array-total-size u) (array-total-size v)))
             (n0 (- n (mod n 8))))
        (if (< n 8)
            (loop for i of-type fixnum below n
                  summing (* (aref u i) (aref v i))
                    into sum of-type single-float
                  finally (return sum))
            (+ (loop with %sum of-type f32.8 = (make-f32.8 0 0 0 0 0 0 0 0)
                     for i of-type fixnum below n0 by 8
                     do (f32.8-incf %sum (f32.8* (f32.8-ref u i) (f32.8-ref v i)))
                     finally (return (f32.8-hsum %sum)))
               (loop for i of-type fixnum from n0 below n
                     summing (* (aref u i) (aref v i))
                       into sum of-type single-float
                     finally (return sum))))))
    (export 'f32.8-vdot))

  (sb-simd::macro-when
      (and (find-symbol "VFMADD231PD" sb-assem::*backend-instruction-set-package*)
           (sb-alien:extern-alien "avx2_supported" sb-alien:int))
      (declaim (ftype (function ((simple-array double-float (*))
                                 (simple-array double-float (*)))
                                double-float) f64.4-vdot))
      (define-inline f64.4-vdot (u v)
      (declare (optimize speed))
      (let* ((n  (min (array-total-size u) (array-total-size v)))
             (n0 (- n (mod n 16))))
        (if (< n 16)
            (loop for i of-type fixnum below n
                  summing (* (aref u i) (aref v i))
                    into sum of-type double-float
                  finally (return sum))
            (+ (sb-vm::%f64.4-vdot u v n0)
               (loop for i of-type fixnum from n0 below n
                     summing (* (aref u i) (aref v i))
                       into sum of-type double-float
                     finally (return sum))))))
      (export 'f64.4-vdot))

    (sb-simd::macro-when
      (and (find-symbol "VFMADD231PS" sb-assem::*backend-instruction-set-package*)
           (sb-alien:extern-alien "avx2_supported" sb-alien:int))
      (declaim (ftype (function ((simple-array single-float (*))
                                 (simple-array single-float (*)))
                                single-float) f32.8-vdot))
      (define-inline f32.8-vdot (u v)
        (declare (optimize speed (safety 0)))
        (let* ((n  (min (array-total-size u) (array-total-size v)))
               (n0 (- n (mod n 32))))
          (if (< n 32)
            (loop for i of-type fixnum below n
                  summing (* (aref u i) (aref v i))
                    into sum of-type single-float
                  finally (return sum))
            (+ (sb-vm::%f32.8-vdot u v n0)
               (loop for i of-type fixnum from n0 below n
                     summing (* (aref u i) (aref v i))
                       into sum of-type single-float
                     finally (return sum))))))
      (export 'f32.8-vdot))

    (sb-simd::macro-when
        (sb-alien:extern-alien "avx2_supported" sb-alien:int)
    (declaim (ftype (function ((simple-array double-float (*)))
                              double-float) f64.4-vsum))
    (define-inline f64.4-vsum (u)
      (declare (optimize speed (safety 0)))
      (let* ((n  (array-total-size u))
             (n0 (- n (mod n 16))))
        (if (< n 16)
            (loop for i of-type fixnum below n
                  summing (aref u i)
                    into sum of-type double-float
                  finally (return sum))
            (+ (sb-vm::%f64.4-vsum u n0)
               (loop for i of-type fixnum from n0 below n
                     summing (aref u i)
                       into sum of-type double-float
                     finally (return sum))))))
    (export 'f64.4-vsum)

      (declaim (ftype (function ((simple-array single-float (*)))
                                single-float) f32.8-vsum))
      (define-inline f32.8-vsum (u)
        (declare (optimize speed (safety 0)))
        (let* ((n  (array-total-size u))
               (n0 (- n (mod n 32))))
          (if (< n 32)
              (loop for i of-type fixnum below n
                    summing (aref u i)
                      into sum of-type single-float
                    finally (return sum))
              (+ (sb-vm::%f32.8-vsum u n0)
                 (loop for i of-type fixnum from n0 below n
                       summing (aref u i)
                         into sum of-type single-float
                       finally (return sum))))))
      (export 'f32.8-vsum))

  (declaim (ftype (function ((simple-array double-float (*))
                             (simple-array double-float (*)))
                            double-float) f64.2-vdot))
  (define-inline f64.2-vdot (u v)
    (declare (optimize speed))
    (let* ((n  (min (array-total-size u) (array-total-size v)))
           (n0 (- n (mod n 2))))
      (if (< n 2)
          (loop for i of-type fixnum below n
                summing (* (aref u i) (aref v i))
                  into sum of-type double-float
                finally (return sum))
          (+ (loop with %sum of-type f64.2 = (make-f64.2 0 0)
                   for i of-type fixnum below n0 by 2
                   do (f64.2-incf %sum (f64.2* (f64.2-ref u i)
                                               (f64.2-ref v i)))
                   finally (return (f64.2-hsum %sum)))
             (loop for i of-type fixnum from n0 below n
                   summing (* (aref u i) (aref v i))
                     into sum of-type double-float
                   finally (return sum))))))
  (export 'f64.2-vdot)

  (declaim (ftype (function ((simple-array single-float (*))
                             (simple-array single-float (*)))
                            single-float) f32.4-vdot))
  (define-inline f32.4-vdot (u v)
    (declare (optimize speed))
    (let* ((n  (min (array-total-size u) (array-total-size v)))
           (n0 (- n (mod n 4))))
      (if (< n 4)
          (loop for i of-type fixnum below n
                summing (* (aref u i) (aref v i))
                  into sum of-type single-float
                finally (return sum))
          (+ (loop with %sum of-type f32.4 = (make-f32.4 0 0 0 0)
                   for i of-type fixnum below n0 by 4
                   do (f32.4-incf %sum (f32.4* (f32.4-ref u i)
                                               (f32.4-ref v i)))
                   finally (return (f32.4-hsum %sum)))
             (loop for i of-type fixnum from n0 below n
                   summing (* (aref u i) (aref v i))
                     into sum of-type single-float
                   finally (return sum))))))
  (export 'f32.4-vdot)

  (declaim (ftype (function ((simple-array double-float (*)))
                            double-float) f64.2-vsum))
  (define-inline f64.2-vsum (u)
    (declare (optimize speed))
    (let* ((n  (array-total-size u))
           (n0 (- n (mod n 2))))
      (if (< n 2)
          (loop for i of-type fixnum below n
                summing (row-major-aref u i)
                  into sum of-type double-float
                finally (return sum))
          (+ (loop with %sum of-type f64.2 = (make-f64.2 0 0)
                   for i of-type fixnum below n0 by 2
                   do (f64.2-incf %sum (f64.2-ref u i))
                   finally (return (f64.2-hsum %sum)))
             (loop for i of-type fixnum from n0 below n
                   summing (row-major-aref u i)
                     into sum of-type double-float
                   finally (return sum))))))
  (export 'f64.2-vsum)

  (declaim (ftype (function ((simple-array single-float (*)))
                            single-float) f32.4-vsum))
  (define-inline f32.4-vsum (u)
    (declare (optimize speed))
    (let* ((n  (array-total-size u))
           (n0 (- n (mod n 4))))
      (if (< n 4)
          (loop for i of-type fixnum below n
                summing (row-major-aref u i)
                  into sum of-type single-float
                finally (return sum))
          (+ (loop with %sum of-type f32.4 = (make-f32.4 0 0 0 0)
                   for i of-type fixnum below n0 by 4
                   do (f32.4-incf %sum (f32.4-ref u i))
                   finally (return (f32.4-hsum %sum)))
             (loop for i of-type fixnum from n0 below n
                   summing (row-major-aref u i)
                     into sum of-type single-float
                   finally (return sum))))))
  (export 'f32.4-vsum)
