(declaim (sb-ext:muffle-conditions style-warning))
(in-package #:sb-vm)
(eval-when (:compile-toplevel :load-toplevel :execute)
  (sb-simd::macro-when
      (and (find-symbol "VFMADD231PD" sb-assem::*backend-instruction-set-package*)
           (sb-alien:extern-alien "avx2_supported" sb-alien:int))
    (defknown (%f64.4-vdot) ((simple-array double-float (*))
                             (simple-array double-float (*))
                             (integer 0 #.most-positive-fixnum))
        (simd-pack double-float)
        (movable flushable always-translatable)
      :overwrite-fndb-silently t)
    (define-vop (%f64.4-vdot)
      (:translate %f64.4-vdot)
      (:policy :fast-safe)
      (:args (u  :scs (descriptor-reg))
             (v  :scs (descriptor-reg))
             (n0-tn :scs (signed-reg)))
      (:arg-types simple-array-double-float simple-array-double-float
                  tagged-num)
      (:temporary (:sc signed-reg) i)
      (:temporary (:sc signed-reg) n0)
      (:temporary (:sc double-avx2-reg) ymm0)
      (:temporary (:sc double-avx2-reg) ymm1)
      (:temporary (:sc double-avx2-reg) ymm2)
      (:temporary (:sc double-avx2-reg) ymm3)
      (:temporary (:sc double-avx2-reg) ymm4)
      (:temporary (:sc double-avx2-reg) ymm5)
      (:temporary (:sc double-avx2-reg) ymm6)
      (:temporary (:sc double-avx2-reg) ymm7)
      (:temporary (:sc double-sse-reg)  xmm0)
      (:temporary (:sc double-sse-reg)  xmm1)
      (:results (result :scs (double-sse-reg)))
      (:result-types simd-pack-double)
      (:generator 22
                  (move n0 n0-tn)
                  (inst vxorpd ymm4 ymm4 ymm4)
                  (inst vxorpd ymm5 ymm5 ymm5)
                  (inst vxorpd ymm6 ymm6 ymm6)
                  (inst vxorpd ymm7 ymm7 ymm7)
                  (inst xor i i)
                  LOOP
                  (inst vmovupd ymm0 (float-ref-ea u i 0 8 :scale 2))
                  (inst vmovupd ymm1 (float-ref-ea u i 4 8 :scale 2))
                  (inst vmovupd ymm2 (float-ref-ea u i 8 8 :scale 2))
                  (inst vmovupd ymm3 (float-ref-ea u i 12 8 :scale 2))
                  (inst vfmadd231pd ymm4 ymm0 (float-ref-ea v i 0 8 :scale 2))
                  (inst vfmadd231pd ymm5 ymm1 (float-ref-ea v i 4 8 :scale 2))
                  (inst vfmadd231pd ymm6 ymm2 (float-ref-ea v i 8 8 :scale 2))
                  (inst vfmadd231pd ymm7 ymm3 (float-ref-ea v i 12 8 :scale 2))
                  (inst add i 16)
                  (inst cmp i n0)
                  (inst jmp :b LOOP)
                  DONE
                  (inst vaddpd ymm4 ymm4 ymm5)
                  (inst vaddpd ymm6 ymm6 ymm7)
                  (inst vaddpd ymm4 ymm4 ymm6)
                  (inst vmovapd xmm0 ymm4)
                  (inst vextractf128 xmm1 ymm4 1)
                  (inst vaddpd xmm0 xmm0 xmm1)
                  (inst vpermilpd xmm1 xmm0 1)
                  (inst vaddsd result xmm0 xmm1))))

  (sb-simd::macro-when
      (and (find-symbol "VFMADD231PS" sb-assem::*backend-instruction-set-package*)
           (sb-alien:extern-alien "avx2_supported" sb-alien:int))
    (defknown (%f32.8-vdot) ((simple-array single-float (*))
                             (simple-array single-float (*))
                             (integer 0 #.most-positive-fixnum))
        (simd-pack single-float)
        (movable flushable always-translatable)
      :overwrite-fndb-silently t)
    (define-vop (%f32.8-vdot)
      (:translate %f32.8-vdot)
      (:policy :fast-safe)
      (:args (u  :scs (descriptor-reg))
             (v  :scs (descriptor-reg))
             (n0-tn :scs (signed-reg)))
      (:arg-types simple-array-single-float simple-array-single-float
                  tagged-num)
      (:temporary (:sc signed-reg) i)
      (:temporary (:sc signed-reg) n0)
      (:temporary (:sc single-avx2-reg) ymm0)
      (:temporary (:sc single-avx2-reg) ymm1)
      (:temporary (:sc single-avx2-reg) ymm2)
      (:temporary (:sc single-avx2-reg) ymm3)
      (:temporary (:sc single-avx2-reg) ymm4)
      (:temporary (:sc single-avx2-reg) ymm5)
      (:temporary (:sc single-avx2-reg) ymm6)
      (:temporary (:sc single-avx2-reg) ymm7)
      (:temporary (:sc single-sse-reg)  xmm0)
      (:temporary (:sc single-sse-reg)  xmm1)
      (:results (result :scs (single-sse-reg)))
      (:result-types simd-pack-single)
      (:generator 22
                  (move n0 n0-tn)
                  (inst vxorps ymm4 ymm4 ymm4)
                  (inst vxorps ymm5 ymm5 ymm5)
                  (inst vxorps ymm6 ymm6 ymm6)
                  (inst vxorps ymm7 ymm7 ymm7)
                  (inst xor i i)
                  LOOP
                  (inst vmovups ymm0 (float-ref-ea u i 0 0))
                  (inst vmovups ymm1 (float-ref-ea u i 8 0))
                  (inst vmovups ymm2 (float-ref-ea u i 16 0))
                  (inst vmovups ymm3 (float-ref-ea u i 24 0))
                  (inst vfmadd231ps ymm4 ymm0 (float-ref-ea v i 0 0))
                  (inst vfmadd231ps ymm5 ymm1 (float-ref-ea v i 8 0))
                  (inst vfmadd231ps ymm6 ymm2 (float-ref-ea v i 16 0))
                  (inst vfmadd231ps ymm7 ymm3 (float-ref-ea v i 24 0))
                  (inst add i 32)
                  (inst cmp i n0)
                  (inst jmp :b LOOP)
                  DONE
                  (inst vaddps ymm4 ymm4 ymm5)
                  (inst vaddps ymm6 ymm6 ymm7)
                  (inst vaddps ymm4 ymm4 ymm6)
                  (inst vmovaps xmm0 ymm4)
                  (inst vextractf128 xmm1 ymm4 1)
                  (inst vaddps xmm0 xmm0 xmm1)
                  (inst vpermilpd xmm1 xmm0 1)
                  (inst vaddps xmm0 xmm0 xmm1)
                  (inst vmovshdup xmm1 xmm0)
                  (inst vaddss result xmm0 xmm1))))

  (sb-simd::macro-when
   (sb-alien:extern-alien "avx_supported" sb-alien:int)
   (defknown (%f64.4-vsum) ((simple-array double-float (*))
                            (integer 0 #.most-positive-fixnum))
       (simd-pack double-float)
       (movable flushable always-translatable)
     :overwrite-fndb-silently t)
   (define-vop (%f64.4-vsum)
     (:translate %f64.4-vsum)
     (:policy :fast-safe)
     (:args (u  :scs (descriptor-reg))
            (n0-tn :scs (signed-reg)))
     (:arg-types simple-array-double-float tagged-num)
     (:temporary (:sc unsigned-reg) i)
     (:temporary (:sc unsigned-reg) n0)
     (:temporary (:sc double-avx2-reg) ymm0)
     (:temporary (:sc double-avx2-reg) ymm1)
     (:temporary (:sc double-avx2-reg) ymm2)
     (:temporary (:sc double-avx2-reg) ymm3)
     (:temporary (:sc double-sse-reg)  xmm0)
     (:temporary (:sc double-sse-reg)  xmm1)
     (:results (result :scs (double-sse-reg)))
     (:result-types simd-pack-double)
     (:generator 16
                 (move n0 n0-tn)
                 (inst vxorpd ymm0 ymm0 ymm0)
                 (inst vxorpd ymm1 ymm1 ymm1)
                 (inst vxorpd ymm2 ymm2 ymm2)
                 (inst vxorpd ymm3 ymm3 ymm3)
                 (inst xor i i)
                 LOOP
                 (inst vaddpd ymm0 ymm0 (float-ref-ea u i 0 0 :scale 4))
                 (inst vaddpd ymm1 ymm1 (float-ref-ea u i 4 0 :scale 4))
                 (inst vaddpd ymm2 ymm2 (float-ref-ea u i 8 0 :scale 4))
                 (inst vaddpd ymm3 ymm3 (float-ref-ea u i 12 0 :scale 4))
                 (inst add i 16)
                 (inst cmp i n0)
                 (inst jmp :b LOOP)
                 DONE
                 (inst vaddpd ymm0 ymm0 ymm1)
                 (inst vaddpd ymm2 ymm2 ymm3)
                 (inst vaddpd ymm0 ymm0 ymm2)
                 (inst vmovapd xmm0 ymm0)
                 (inst vextractf128 xmm1 ymm0 1)
                 (inst vzeroupper)
                 (inst vaddpd xmm0 xmm0 xmm1)
                 (inst vunpckhpd xmm1 xmm0 xmm0)
                 (inst vaddsd result xmm0 xmm1)))

    (defknown (%f32.8-vsum) ((simple-array single-float (*))
                             (integer 0 #.most-positive-fixnum))
        (simd-pack single-float)
        (movable flushable always-translatable)
      :overwrite-fndb-silently t)
    (define-vop (%f32.8-vsum)
      (:translate %f32.8-vsum)
      (:policy :fast-safe)
      (:args (u  :scs (descriptor-reg))
             (n0-tn :scs (signed-reg)))
      (:arg-types simple-array-single-float tagged-num)
      (:temporary (:sc signed-reg) i)
      (:temporary (:sc signed-reg) n0)
      (:temporary (:sc single-avx2-reg) ymm0)
      (:temporary (:sc single-avx2-reg) ymm1)
      (:temporary (:sc single-avx2-reg) ymm2)
      (:temporary (:sc single-avx2-reg) ymm3)
      (:temporary (:sc single-sse-reg)  xmm0)
      (:temporary (:sc single-sse-reg)  xmm1)
      (:results (result :scs (single-sse-reg)))
      (:result-types simd-pack-single)
      (:generator 22
                  (move n0 n0-tn)
                  (inst vxorps ymm0 ymm0 ymm0)
                  (inst vxorps ymm1 ymm1 ymm1)
                  (inst vxorps ymm2 ymm2 ymm2)
                  (inst vxorps ymm3 ymm3 ymm3)
                  (inst xor i i)
                  LOOP
                  (inst vaddps ymm0 ymm0 (float-ref-ea u i 0 0))
                  (inst vaddps ymm1 ymm1 (float-ref-ea u i 8 0))
                  (inst vaddps ymm2 ymm2 (float-ref-ea u i 16 0))
                  (inst vaddps ymm3 ymm3 (float-ref-ea u i 24 0))
                  (inst add i 32)
                  (inst cmp i n0)
                  (inst jmp :b LOOP)
                  DONE
                  (inst vaddps ymm0 ymm0 ymm1)
                  (inst vaddps ymm2 ymm2 ymm3)
                  (inst vaddps ymm0 ymm0 ymm2)
                  (inst vmovapd xmm0 ymm0)
                  (inst vextractf128 xmm1 ymm0 1)
                  (inst vaddps xmm0 xmm0 xmm1)
                  (inst vpermilpd xmm1 xmm0 1)
                  (inst vaddps xmm0 xmm0 xmm1)
                  (inst vmovshdup xmm1 xmm0)
                  (inst vaddss result xmm0 xmm1)))

    (defknown (%f64.4-hsum) ((simd-pack-256 double-float))
          (simd-pack double-float)
          (movable flushable always-translatable)
        :overwrite-fndb-silently t)
      (define-vop (%f64.4-hsum)
        (:translate %f64.4-hsum)
        (:policy :fast-safe)
        (:args (x :scs (double-avx2-reg)))
        (:arg-types simd-pack-256-double)
        (:temporary (:sc double-sse-reg) xmm0)
        (:temporary (:sc double-sse-reg) xmm1)
        (:results (result :scs (double-sse-reg)))
        (:result-types simd-pack-double)
        (:generator 4 ;; what should be the cost?
                    (inst vmovapd xmm0 x)
                    (inst vextractf128 xmm1 x 1)
                    (inst vaddpd xmm0 xmm0 xmm1)
                    (inst vpermilpd xmm1 xmm0 1)
                    (inst vaddsd result xmm0 xmm1)))

      (defknown (%f32.8-hsum) ((simd-pack-256 single-float))
          (simd-pack single-float)
          (movable flushable always-translatable)
        :overwrite-fndb-silently t)
      (define-vop (%f32.8-hsum)
        (:translate %f32.8-hsum)
        (:policy :fast-safe)
        (:args (x :scs (single-avx2-reg)))
        (:arg-types simd-pack-256-single)
        (:temporary (:sc single-sse-reg) xmm0)
        (:temporary (:sc single-sse-reg) xmm1)
        (:results (result :scs (single-sse-reg)))
        (:result-types simd-pack-single)
        (:generator 4 ;; what should be the cost?
                    (inst vmovapd xmm0 x)
                    (inst vextractf128 xmm1 x 1)
                    (inst vaddps xmm0 xmm0 xmm1)
                    (inst vpermilpd xmm1 xmm0 1)
                    (inst vaddps  xmm0 xmm0 xmm1)
                    (inst vmovshdup xmm1 xmm0)
                    (inst vaddss result xmm0 xmm1)))

    (defknown (%f64.2-hsum) ((simd-pack double-float))
        (simd-pack double-float)
        (movable flushable always-translatable)
      :overwrite-fndb-silently t)
    (define-vop (%f64.2-hsum)
      (:translate %f64.2-hsum)
      (:policy :fast-safe)
      (:args (x :scs (double-sse-reg)))
      (:arg-types simd-pack-double)
      (:temporary (:sc double-sse-reg) xmm0)
      (:temporary (:sc double-sse-reg) xmm1)
      (:results (result :scs (double-sse-reg)))
      (:result-types simd-pack-double)
      (:generator 4 ;; what should be the cost?
                  (inst vmovapd xmm0 x)
                  (inst vextractf128 xmm1 x 1)
                  (inst vaddpd xmm0 xmm0 xmm1)
                  (inst vunpckhpd xmm1 xmm0 xmm0)
                  (inst vaddsd result xmm0 xmm1)))

    (defknown (%f32.4-hsum) ((simd-pack single-float))
        (simd-pack single-float)
        (movable flushable always-translatable)
      :overwrite-fndb-silently t)
    (define-vop (%f32.4-hsum)
      (:translate %f32.4-hsum)
      (:policy :fast-safe)
      (:args (xmm0 :scs (single-sse-reg)))
      (:arg-types simd-pack-single)
      (:temporary (:sc single-sse-reg) xmm1)
      (:results (result :scs (single-sse-reg)))
      (:result-types simd-pack-single)
      (:generator 4 ;; what should be the cost?
                  (inst movshdup xmm1 xmm0)
                  (inst addps xmm0 xmm1)
                  (inst movhlps xmm1 xmm0)
                  (inst addss result xmm1)))))

(in-package #:sb-simd)
(eval-when (:compile-toplevel :load-toplevel :execute)
  (sb-simd::macro-when
      (sb-alien:extern-alien "avx2_supported" sb-alien:int)
    (declaim (ftype (function (f64.2) double-float) f64.2-hsum))
    (define-inline f64.2-hsum (%x)
      (declare (optimize (speed 3)))
      (sb-vm::%simd-pack-double-item (sb-vm::%f64.2-hsum %x) 0))
    (export 'f64.2-hsum)

    (declaim (ftype (function (f32.4) single-float) f32.4-hsum))
    (define-inline f32.4-hsum (%x)
      (declare (optimize (speed 3)))
      (sb-vm::%simd-pack-single-item (sb-vm::%f32.4-hsum %x) 0))
    
  (export 'f32.4-hsum)
    (declaim (ftype (function (f64.4) double-float) f64.4-hsum))
    (define-inline f64.4-hsum (%x)
      (declare (optimize speed))
      (sb-vm::%simd-pack-double-item (sb-vm::%f64.4-hsum %x) 0))
    (export 'f64.4-hsum)

    (declaim (ftype (function (f32.8) single-float) f32.8-hsum))
    (define-inline f32.8-hsum (%x)
      (declare (optimize speed))
      (sb-vm::%simd-pack-single-item (sb-vm::%f32.8-hsum %x) 0))
    (export 'f32.8-hsum))

  (sb-simd::macro-when
      (and (not (find-symbol "VFMADD231PD" sb-assem::*backend-instruction-set-package*))
           (sb-alien:extern-alien "avx2_supported" sb-alien:int))
    (declaim (ftype (function ((simple-array double-float (*))
                               (simple-array double-float (*)))
                              double-float) f64.4-vdot))
    (define-inline f64.4-vdot (u v)
      (declare (optimize speed))
      (let* ((n  (min (array-total-size u) (array-total-size v)))
             (n0 (- n (mod n 4))))
        (if (< n 4)
            (loop for i of-type fixnum below n
                  summing (* (aref u i) (aref v i))
                    into sum of-type double-float
                  finally (return sum))
            (+ (loop with %sum of-type f64.4 = (make-f64.4 0 0 0 0)
                     for i of-type fixnum below n0 by 4
                     do (f64.4-incf %sum (f64.4* (f64.4-ref u i) (f64.4-ref v i)))
                     finally (return (f64.4-hsum %sum)))
               (loop for i of-type fixnum from n0 below n
                     summing (* (aref u i) (aref v i))
                       into sum of-type double-float
                     finally (return sum))))))
    (export 'f64.4-vdot)

    (declaim (ftype (function ((simple-array single-float (*))
                               (simple-array single-float (*)))
                              single-float) f32.8-vdot))
    (define-inline f32.8-vdot (u v)
      (declare (optimize speed))
      (let* ((n  (min (array-total-size u) (array-total-size v)))
             (n0 (- n (mod n 8))))
        (if (< n 8)
            (loop for i of-type fixnum below n
                  summing (* (aref u i) (aref v i))
                    into sum of-type single-float
                  finally (return sum))
            (+ (loop with %sum of-type f32.8 = (make-f32.8 0 0 0 0 0 0 0 0)
                     for i of-type fixnum below n0 by 8
                     do (f32.8-incf %sum (f32.8* (f32.8-ref u i) (f32.8-ref v i)))
                     finally (return (f32.8-hsum %sum)))
               (loop for i of-type fixnum from n0 below n
                     summing (* (aref u i) (aref v i))
                       into sum of-type single-float
                     finally (return sum))))))
    (export 'f32.8-vdot))

  (sb-simd::macro-when
      (and (find-symbol "VFMADD231PD" sb-assem::*backend-instruction-set-package*)
           (sb-alien:extern-alien "avx2_supported" sb-alien:int))
      (declaim (ftype (function ((simple-array double-float (*))
                                 (simple-array double-float (*)))
                                double-float) f64.4-vdot))
      (define-inline f64.4-vdot (u v)
      (declare (optimize speed))
      (let* ((n  (min (array-total-size u) (array-total-size v)))
             (n0 (- n (mod n 16))))
        (if (< n 16)
            (loop for i of-type fixnum below n
                  summing (* (aref u i) (aref v i))
                    into sum of-type double-float
                  finally (return sum))
            (+ (sb-vm::%simd-pack-double-item (sb-vm::%f64.4-vdot u v n0) 0)
               (loop for i of-type fixnum from n0 below n
                     summing (* (aref u i) (aref v i))
                       into sum of-type double-float
                     finally (return sum))))))
      (export 'f64.4-vdot))

    (sb-simd::macro-when
      (and (find-symbol "VFMADD231PS" sb-assem::*backend-instruction-set-package*)
           (sb-alien:extern-alien "avx2_supported" sb-alien:int))
      (declaim (ftype (function ((simple-array single-float (*))
                                 (simple-array single-float (*)))
                                single-float) f32.8-vdot))
      (define-inline f32.8-vdot (u v)
        (declare (optimize speed (safety 0)))
        (let* ((n  (min (array-total-size u) (array-total-size v)))
               (n0 (- n (mod n 32))))
          (if (< n 32)
            (loop for i of-type fixnum below n
                  summing (* (aref u i) (aref v i))
                    into sum of-type single-float
                  finally (return sum))
            (+ (sb-vm::%simd-pack-single-item (sb-vm::%f32.8-vdot u v n0) 0)
                   (loop for i of-type fixnum from n0 below n
                         summing (* (aref u i) (aref v i))
                           into sum of-type single-float
                         finally (return sum))))))
      (export 'f32.8-vdot))

    (sb-simd::macro-when
        (sb-alien:extern-alien "avx2_supported" sb-alien:int)
    (declaim (ftype (function ((simple-array double-float (*)))
                              double-float) f64.4-vsum))
    (define-inline f64.4-vsum (u)
      (declare (optimize speed (safety 0)))
      (let* ((n  (array-total-size u))
             (n0 (- n (mod n 16))))
        (if (< n 16)
            (loop for i of-type fixnum below n
                  summing (aref u i)
                    into sum of-type double-float
                  finally (return sum))
            (+ (sb-vm::%simd-pack-double-item (sb-vm::%f64.4-vsum u n0) 0)
               (loop for i of-type fixnum from n0 below n
                     summing (aref u i)
                       into sum of-type double-float
                     finally (return sum))))))
    (export 'f64.4-vsum)

      (declaim (ftype (function ((simple-array single-float (*)))
                                single-float) f32.8-vsum))
      (define-inline f32.8-vsum (u)
        (declare (optimize speed (safety 0)))
        (let* ((n  (array-total-size u))
               (n0 (- n (mod n 32))))
          (if (< n 32)
              (loop for i of-type fixnum below n
                    summing (aref u i)
                      into sum of-type single-float
                    finally (return sum))
              (+ (sb-vm::%simd-pack-single-item (sb-vm::%f32.8-vsum u n0) 0)
                 (loop for i of-type fixnum from n0 below n
                       summing (aref u i)
                         into sum of-type single-float
                       finally (return sum))))))
      (export 'f32.8-vsum))

  (declaim (ftype (function ((simple-array double-float (*))
                             (simple-array double-float (*)))
                            double-float) f64.2-vdot))
  (define-inline f64.2-vdot (u v)
    (declare (optimize speed))
    (let* ((n  (min (array-total-size u) (array-total-size v)))
           (n0 (- n (mod n 2))))
      (if (< n 2)
          (loop for i of-type fixnum below n
                summing (* (aref u i) (aref v i))
                  into sum of-type double-float
                finally (return sum))
          (+ (loop with %sum of-type f64.2 = (make-f64.2 0 0)
                   for i of-type fixnum below n0 by 2
                   do (f64.2-incf %sum (f64.2* (f64.2-ref u i)
                                               (f64.2-ref v i)))
                   finally (return (f64.2-hsum %sum)))
             (loop for i of-type fixnum from n0 below n
                   summing (* (aref u i) (aref v i))
                     into sum of-type double-float
                   finally (return sum))))))
  (export 'f64.2-vdot)

  (declaim (ftype (function ((simple-array single-float (*))
                             (simple-array single-float (*)))
                            single-float) f32.4-vdot))
  (define-inline f32.4-vdot (u v)
    (declare (optimize speed))
    (let* ((n  (min (array-total-size u) (array-total-size v)))
           (n0 (- n (mod n 4))))
      (if (< n 4)
          (loop for i of-type fixnum below n
                summing (* (aref u i) (aref v i))
                  into sum of-type single-float
                finally (return sum))
          (+ (loop with %sum of-type f32.4 = (make-f32.4 0 0 0 0)
                   for i of-type fixnum below n0 by 4
                   do (f32.4-incf %sum (f32.4* (f32.4-ref u i)
                                               (f32.4-ref v i)))
                   finally (return (f32.4-hsum %sum)))
             (loop for i of-type fixnum from n0 below n
                   summing (* (aref u i) (aref v i))
                     into sum of-type single-float
                   finally (return sum))))))
  (export 'f32.4-vdot)

  (declaim (ftype (function ((simple-array double-float (*)))
                            double-float) f64.2-vsum))
  (define-inline f64.2-vsum (u)
    (declare (optimize speed))
    (let* ((n  (array-total-size u))
           (n0 (- n (mod n 2))))
      (if (< n 2)
          (loop for i of-type fixnum below n
                summing (row-major-aref u i)
                  into sum of-type double-float
                finally (return sum))
          (+ (loop with %sum of-type f64.2 = (make-f64.2 0 0)
                   for i of-type fixnum below n0 by 2
                   do (f64.2-incf %sum (f64.2-ref u i))
                   finally (return (f64.2-hsum %sum)))
             (loop for i of-type fixnum from n0 below n
                   summing (row-major-aref u i)
                     into sum of-type double-float
                   finally (return sum))))))
  (export 'f64.2-vsum)

  (declaim (ftype (function ((simple-array single-float (*)))
                            single-float) f32.4-vsum))
  (define-inline f32.4-vsum (u)
    (declare (optimize speed))
    (let* ((n  (array-total-size u))
           (n0 (- n (mod n 4))))
      (if (< n 4)
          (loop for i of-type fixnum below n
                summing (row-major-aref u i)
                  into sum of-type single-float
                finally (return sum))
          (+ (loop with %sum of-type f32.4 = (make-f32.4 0 0 0 0)
                   for i of-type fixnum below n0 by 4
                   do (f32.4-incf %sum (f32.4-ref u i))
                   finally (return (f32.4-hsum %sum)))
             (loop for i of-type fixnum from n0 below n
                   summing (row-major-aref u i)
                     into sum of-type single-float
                   finally (return sum))))))
  (export 'f32.4-vsum)
  )
